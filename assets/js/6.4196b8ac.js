(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{359:function(v,_,e){v.exports=e.p+"assets/img/reaster.a8d954cd.png"},373:function(v,_,e){"use strict";e.r(_);var s=e(25),l=Object(s.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("ul",[s("li",[s("p",[v._v("构建DOM 树 : 将html 转化为浏览器能识别的document tree")])]),v._v(" "),s("li",[s("p",[v._v("计算样式: 浏览器无法直接识别css,将css转化为styleSheets,其中涉及到:css的继承和层叠")])]),v._v(" "),s("li",[s("p",[v._v("布局")]),v._v(" "),s("ul",[s("li",[s("p",[v._v("根据构建出来的DOM 和 计算出来的样式,浏览器会在布局阶段完成两个任务:生成布局树和布局计算")])]),v._v(" "),s("li",[s("p",[v._v("生成布局树: 遍历DOM树所有可见的节点,将他们加到布局树,")]),v._v(" "),s("ul",[s("li",[s("p",[v._v("忽略不可见的节点")]),v._v(" "),s("ul",[s("li",[v._v("比如:head信息, display: none的元素都建被忽略")])])]),v._v(" "),s("li",[s("p",[v._v("计算布局: 计算布局阶段会将运算好的结果重新写会布局树"),s("span",{staticStyle:{display:"none"}},[v._v(".所以布局树即是输入内容 也是 输出内容,输入和输出内容没分开,不太合理,谷歌在重构(layoutNG)")])])]),v._v(" "),s("li",[s("p",[v._v("会计算出所有dom节点的样式 位置等")])])])])])]),v._v(" "),s("li",[s("p",[v._v("分层(为了更好的实现一些复杂的效果(3D 装换, z-index,页面滚动等): 渲染引擎会"),s("strong",[v._v("根据布局树")]),v._v("为一些特定的节点生成分层树[layer tree])")]),v._v(" "),s("ul",[s("li",[v._v("拥有"),s("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context",target:"_blank",rel:"noopener noreferrer"}},[v._v("层叠上文"),s("OutboundLink")],1),v._v("属性的元素会被单独提升为一层")]),v._v(" "),s("li",[v._v("需要裁减的地方也会创建图层\n"),s("ul",[s("li",[v._v("超出当前图层的或者div的部份会出现滚动条,滚动条也会单独为一个图层,超出的部份会被裁减,也会被创建为图层")])])])]),v._v(" "),s("ul",[s("li",[v._v("图层绘制\n"),s("ul",[s("li",[v._v("渲染去引擎会把图层的绘制拆分成很多小的绘制指令,然后在将这些指令按一定的顺序排列成一个待"),s("code",[v._v("绘制列表")]),v._v(".")])])])])]),v._v(" "),s("li",[s("p",[v._v("栅格化")]),v._v(" "),s("ul",[s("li",[s("code",[v._v("绘制列表")]),v._v("只是用来记录绘制顺序和指令的.真正的绘制是渲染引擎的合成线程来完成的\n"),s("ul",[s("li",[v._v("当图层的绘制列表准备好以后,主线程会把该列表提交到合成线程")])])]),v._v(" "),s("li",[v._v("视口: 浏览器中用户可以看得到的部份,在有些情况下，\n"),s("ul",[s("li",[v._v("有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。")]),v._v(" "),s("li",[v._v("基于上面的原因,"),s("strong",[v._v("合成线程会将图层划分为图块")]),v._v(":大小通常为"),s("code",[v._v("256*256")]),v._v(",或 "),s("code",[v._v("512*512")])]),v._v(" "),s("li",[v._v("然后"),s("strong",[v._v("合成线程会将视口附近的图块优先生成位图,但实际上生成位图是由合成线程来完成的;所谓的栅格化:是将图层转化为位图")]),v._v(",而图块是栅格化最小单位,渲染进程维护了一个栅格化的线程池,所有的图块栅格化都是在线程池中完成的")]),v._v(" "),s("li",[v._v("通常: 栅格化的过程都会是使用GPU来加速,使用GPU将图块栅格化为位图的过程叫: 快速栅格化或者GPU 栅格化,然后将位图保存在GPU内存中")])])])]),v._v(" "),s("p",[s("img",{attrs:{src:e(359),alt:"img"}})])]),v._v(" "),s("li",[s("p",[v._v("合成与显示")]),v._v(" "),s("ul",[s("li",[v._v("如果在生成位图(栅格化)使用了GPU,那生成的位图是在GPU进程中完成的.这里会涉及到跨进程.\n"),s("ol",[s("li",[v._v("首先渲染进程里执行图层合成(Layer Compositor)，也就是生成图层的操作，具体地讲，渲染进程的合成线程接收到图层的绘制消息时，会通过光栅化线程池将其提交给GPU进程，在GPU进程中执行光栅化操作，执行完成，再将结果返回给渲染进程的合成线程，执行合成图层操作！")]),v._v(" "),s("li",[v._v("合成的图层会被提交给浏览器进程，浏览器进程里会执行显示合成(Display Compositor)，也就是将所有的图层合成为可以显示的页面图片。 最终显示器显示的就是浏览器进程中合成的页面图片")])])]),v._v(" "),s("li",[v._v('所以一旦栅格化完所有图块,合成线程就会生成一个绘制图块的命令---- "DrawQuad",然后将该命令提交给浏览器进程')]),v._v(" "),s("li",[v._v("然后浏览器进程中的viz组件会接收处理"),s("code",[v._v("**DrawQuad**")]),v._v("命令,将其页面内容绘制到内存中,最后在将内存显示到屏幕上")])])]),v._v(" "),s("li",[s("p",[v._v("总结")]),v._v(" "),s("ol",[s("li",[v._v("渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。")]),v._v(" "),s("li",[v._v("渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。")]),v._v(" "),s("li",[v._v("创建布局树，并计算元素的布局信息。对布局树进行分层，并生成分层树。")]),v._v(" "),s("li",[v._v("为每个图层生成绘制列表，并将其提交到合成线程。")]),v._v(" "),s("li",[v._v("合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。")]),v._v(" "),s("li",[v._v("合成线程发送绘制图块命令 DrawQuad 给浏览器进程。")]),v._v(" "),s("li",[v._v("浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。")])])]),v._v(" "),s("li",[s("p",[v._v("重排(改变元素的几何属性:eg: height,wdith...)会导致浏览器重新执行渲染流程")])]),v._v(" "),s("li",[s("p",[v._v("重绘(更新元素的绘制属性: eg: background,color...):因为没有几何位置的变化,和重排相比会少去布局和分层阶段")])]),v._v(" "),s("li",[s("p",[v._v("合成(不改变几何属性和绘制属性: eg: transform):只需要在合成阶段去处理合成动画")])]),v._v(" "),s("li",[s("p",[v._v("减少重绘重排的方法")]),v._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[v._v("1.")]),v._v(" 使用 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("class")]),v._v(" 操作样式，而不是频繁操作 style\n"),s("span",{pre:!0,attrs:{class:"token number"}},[v._v("2.")]),v._v(" 避免使用 table 布局\n"),s("span",{pre:!0,attrs:{class:"token number"}},[v._v("3.")]),v._v(" 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React\n"),s("span",{pre:!0,attrs:{class:"token number"}},[v._v("4.")]),v._v(" Debounce window resize 事件\n"),s("span",{pre:!0,attrs:{class:"token number"}},[v._v("5.")]),v._v(" 对 dom 属性的读写要分离\n"),s("span",{pre:!0,attrs:{class:"token number"}},[v._v("6.")]),v._v(" will"),s("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("change"),s("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" transform 做优化\n")])]),v._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[v._v("1")]),s("br"),s("span",{staticClass:"line-number"},[v._v("2")]),s("br"),s("span",{staticClass:"line-number"},[v._v("3")]),s("br"),s("span",{staticClass:"line-number"},[v._v("4")]),s("br"),s("span",{staticClass:"line-number"},[v._v("5")]),s("br"),s("span",{staticClass:"line-number"},[v._v("6")]),s("br")])])])])])}),[],!1,null,null,null);_.default=l.exports}}]);