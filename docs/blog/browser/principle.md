- 构建DOM 树 : 将html 转化为浏览器能识别的document tree

- 计算样式: 浏览器无法直接识别css,将css转化为styleSheets,其中涉及到:css的继承和层叠

- 布局

  - 根据构建出来的DOM 和 计算出来的样式,浏览器会在布局阶段完成两个任务:生成布局树和布局计算

  - 生成布局树: 遍历DOM树所有可见的节点,将他们加到布局树,

    - 忽略不可见的节点
      - 比如:head信息, display: none的元素都建被忽略

    - 计算布局: 计算布局阶段会将运算好的结果重新写会布局树<span style="display:none;">.所以布局树即是输入内容 也是 输出内容,输入和输出内容没分开,不太合理,谷歌在重构(layoutNG)</span>
    - 会计算出所有dom节点的样式 位置等

- 分层(为了更好的实现一些复杂的效果(3D 装换, z-index,页面滚动等): 渲染引擎会**根据布局树**为一些特定的节点生成分层树[layer tree])

  - 拥有[层叠上文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)属性的元素会被单独提升为一层
  - 需要裁减的地方也会创建图层
    - 超出当前图层的或者div的部份会出现滚动条,滚动条也会单独为一个图层,超出的部份会被裁减,也会被创建为图层

  * 图层绘制
    * 渲染去引擎会把图层的绘制拆分成很多小的绘制指令,然后在将这些指令按一定的顺序排列成一个待`绘制列表`.

- 栅格化

  - `绘制列表`只是用来记录绘制顺序和指令的.真正的绘制是渲染引擎的合成线程来完成的
    - 当图层的绘制列表准备好以后,主线程会把该列表提交到合成线程
  - 视口: 浏览器中用户可以看得到的部份,在有些情况下，
    - 有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。
    - 基于上面的原因,**合成线程会将图层划分为图块**:大小通常为`256*256`,或 `512*512`
    - 然后**合成线程会将视口附近的图块优先生成位图,但实际上生成位图是由合成线程来完成的;所谓的栅格化:是将图层转化为位图**,而图块是栅格化最小单位,渲染进程维护了一个栅格化的线程池,所有的图块栅格化都是在线程池中完成的
    - 通常: 栅格化的过程都会是使用GPU来加速,使用GPU将图块栅格化为位图的过程叫: 快速栅格化或者GPU 栅格化,然后将位图保存在GPU内存中

  ![img](./reaster.png)

- 合成与显示

  - 如果在生成位图(栅格化)使用了GPU,那生成的位图是在GPU进程中完成的.这里会涉及到跨进程.
    1. 首先渲染进程里执行图层合成(Layer Compositor)，也就是生成图层的操作，具体地讲，渲染进程的合成线程接收到图层的绘制消息时，会通过光栅化线程池将其提交给GPU进程，在GPU进程中执行光栅化操作，执行完成，再将结果返回给渲染进程的合成线程，执行合成图层操作！
    2. 合成的图层会被提交给浏览器进程，浏览器进程里会执行显示合成(Display Compositor)，也就是将所有的图层合成为可以显示的页面图片。 最终显示器显示的就是浏览器进程中合成的页面图片
  - 所以一旦栅格化完所有图块,合成线程就会生成一个绘制图块的命令---- "DrawQuad",然后将该命令提交给浏览器进程
  - 然后浏览器进程中的viz组件会接收处理`**DrawQuad**`命令,将其页面内容绘制到内存中,最后在将内存显示到屏幕上

- 总结

  1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
  2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
  3. 创建布局树，并计算元素的布局信息。对布局树进行分层，并生成分层树。
  4. 为每个图层生成绘制列表，并将其提交到合成线程。
  5. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
  6. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
  7. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

- 重排(改变元素的几何属性:eg: height,wdith...)会导致浏览器重新执行渲染流程

- 重绘(更新元素的绘制属性: eg: background,color...):因为没有几何位置的变化,和重排相比会少去布局和分层阶段 

- 合成(不改变几何属性和绘制属性: eg: transform):只需要在合成阶段去处理合成动画

- 减少重绘重排的方法

  ```javascript
  1. 使用 class 操作样式，而不是频繁操作 style
  2. 避免使用 table 布局
  3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
  4. Debounce window resize 事件
  5. 对 dom 属性的读写要分离
  6. will-change: transform 做优化
  ```

  

  